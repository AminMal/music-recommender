package ir.ac.usc
package controllers

import akka.actor.{Actor, ActorLogging, PoisonPill, Props}
import models.{RecommendationResult, SongDTO}
import utils.{ResultParser, ResultParserImpl}
import controllers.RecommendationController.defaultTrendingSongs

import exception.EntityNotFoundException
import utils.box.BoxSupport
import org.apache.spark.mllib.recommendation.MatrixFactorizationModel

import java.time.temporal.ChronoUnit


/**
 * This actor (controller) handles recommending songs for users, based on the MatrixFactorizationModel
 * generated by context manager actor. and is managed by recommender manager actor and killed right after
 * the job is done.
 * @param resultParser an implementation of result parser to fetch user and song data from DataFrames
 */
class RecommendationController(resultParser: ResultParser) extends Actor with ActorLogging with BoxSupport {

  import RecommendationController.Messages._
  import utils.Common.timeTrack
  override def receive: Receive = initialReceive

  val defaultResult: Int => RecommendationResult = userId =>
    new RecommendationResult(
      userId = userId, songs = defaultTrendingSongs
    )

  def initialReceive: Receive = {
    case UpdateContext(model) =>
      context.become(receiveWithModel(model))
      log.info(s"update factorization model in recommender actor")

    case GetRecommendations(userId, count) =>
      sender() ! toBox(new RecommendationResult(
        userId = userId,
        songs = defaultTrendingSongs.take(count)
      ))
      self ! PoisonPill
  }

  def receiveWithModel(model: MatrixFactorizationModel): Receive = {
    case GetRecommendations(userId, count) =>

      val recommendationResult = for {
        user <- toBox {
          timeTrack {
            resultParser.getUserInfo(userId)
              .getOrElse(throw EntityNotFoundException(entity = "user", id = Some(userId.toString)))
          } (operationName = Some("Get user info"), ChronoUnit.MILLIS)
        }
        _ = log.info(s"Found user: $user")

        recommendations <- toBox {
          timeTrack {
          model.recommendProducts(userId, count)
          }(operationName = Some("Getting recommendations from model"), ChronoUnit.MILLIS)
        }
        _ = log.info(s"Got ratings: ${recommendations.toSeq}")

        songs <- toBox {
          timeTrack {
            resultParser.getSongDTOs(recommendations)
          }(operationName = Some("Getting song info from recommendation result"), ChronoUnit.MILLIS)
        }
      } yield new RecommendationResult(userId = userId, songs = songs.take(count))

      sender() ! recommendationResult
      self ! PoisonPill
  }

}

object RecommendationController {

  /**
   * Generates recommendation controller actor Props in order to create new reference of this actor.
   * @return props for this actor
   */
  def props: Props = Props(new RecommendationController(new ResultParserImpl()))

  /**
   * Messages that this actor accepts.
   */
  object Messages {
    case class UpdateContext(model: MatrixFactorizationModel)
    case class GetRecommendations(userId: Int, count: Int = 6)
  }

  val defaultTrendingSongs: Seq[SongDTO] = Seq(
    SongDTO.mock(id = 125323L, name = "Coloratura", artistName = "Coldplay"),
    SongDTO.mock(id = 321534L, name = "Do I wanna know?", artistName = "Arctic monkeys"),
    SongDTO.mock(id = 413416L, name = "Love and hate", artistName = "Michael Kiwanuka"),
    SongDTO.mock(id = 782351L, name = "Riders on the storm", artistName = "The doors"),
    SongDTO.mock(id = 213632L, name = "Lucky town", artistName = "Bruce Springsteen"),
    SongDTO.mock(id = 783294L, name = "Paragon", artistName = "Soen")
  )
}
