package scommender
package controllers

import controllers.RecommendationController.defaultTrendingSongs
import exception.EntityNotFoundException
import models.{RecommendationResult, SongDTO}
import utils.box.BoxSupport
import utils.{DataFrameProvider, ResultParser, ResultParserImpl}

import akka.actor.{Actor, ActorLogging, PoisonPill, Props}
import org.apache.spark.mllib.recommendation.MatrixFactorizationModel

import java.time.temporal.ChronoUnit


/**
 * This actor (controller) handles recommending songs for users, based on the MatrixFactorizationModel
 * generated by context manager actor. and is managed by recommender manager actor and killed right after
 * the job is done.
 *
 * @param resultParser an implementation of result parser to fetch user and song data from DataFrames
 */
private[controllers] class RecommendationController(resultParser: ResultParser) extends Actor with ActorLogging with BoxSupport {

  import utils.TimeUtils.timeTrack
  import RecommendationController.Messages._


  override def receive: Receive = initialReceive

  def initialReceive: Receive = {
    case UpdateContext(model) =>
      context.become(receiveWithModel(model))
      log.info(s"update factorization model in recommender actor")

    case GetRecommendations(userId, count) =>
      sender() ! toBox(new RecommendationResult(
        userId = userId,
        songs = defaultTrendingSongs.take(count)
      ))
      self ! PoisonPill
  }

  def receiveWithModel(model: MatrixFactorizationModel): Receive = {
    case GetRecommendations(userId, count) =>

      val recommendationResult = for {
        user <- toBox {
          timeTrack(operationName = "Get user info", ChronoUnit.MILLIS) {
            resultParser.getUserInfo(userId)
              .getOrElse(throw EntityNotFoundException(entity = "user", id = Some(userId.toString)))
          }
        }
        _ = log.info(s"Found user: $user")

        recommendations <- toBox {
          timeTrack(operationName = "Getting recommendations from model", ChronoUnit.MILLIS) {
            model.recommendProducts(userId, count)
          }
        }
        _ = log.info(s"Got ratings: ${recommendations.toSeq}")

        songs <- toBox {
          timeTrack(operationName = "Getting song info from recommendation result", ChronoUnit.MILLIS) {
            resultParser.getSongDTOs(recommendations)
          }
        }
      } yield new RecommendationResult(userId = userId, songs = songs.take(count))

      sender() ! recommendationResult
      self ! PoisonPill
  }

}

object RecommendationController {

  val defaultTrendingSongs: Seq[SongDTO] = Seq(
    SongDTO.mock(id = 125323L, name = "Coloratura", artistName = "Coldplay"),
    SongDTO.mock(id = 321534L, name = "Do I wanna know?", artistName = "Arctic monkeys"),
    SongDTO.mock(id = 413416L, name = "Love and hate", artistName = "Michael Kiwanuka"),
    SongDTO.mock(id = 782351L, name = "Riders on the storm", artistName = "The doors"),
    SongDTO.mock(id = 213632L, name = "Lucky town", artistName = "Bruce Springsteen"),
    SongDTO.mock(id = 783294L, name = "Paragon", artistName = "Soen")
  )

  /**
   * Generates recommendation controller actor Props in order to create new reference of this actor.
   *
   * @return props for this actor
   */
  def props(dataFrameProvider: DataFrameProvider): Props =
    Props(new RecommendationController(new ResultParserImpl(dataFrameProvider)))

  /**
   * Messages that this actor accepts.
   */
  object Messages {
    case class UpdateContext(model: MatrixFactorizationModel)

    case class GetRecommendations(userId: Int, count: Int = 6)
  }
}
